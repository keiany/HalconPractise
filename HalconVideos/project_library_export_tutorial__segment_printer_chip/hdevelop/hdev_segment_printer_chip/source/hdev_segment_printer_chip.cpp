/*****************************************************************************
 * File generated by HDevelop Version 19.05
 *
 * Do not modify!
 *****************************************************************************/

#include "hdev_segment_printer_chip.h"

#include <algorithm>
#include <map>
#include <mutex>
#include <string>

#ifndef __APPLE__
  #include <hdevengine/HDevEngineCpp.h>
#else
  #include <HDevEngineCpp/HDevEngineCpp.h>
#endif

using namespace HalconCpp;
using namespace HDevEngineCpp;

namespace hdev_segment_printer_chip {

  std::string sgResourcePath;
  
  bool AddResourcePathToProcedurePath()
  {
    HDevEngineCpp::HDevEngine().AddProcedurePath(sgResourcePath.c_str());
    return true;
  }

  bool LazyInitProcedurePath()
  {
    static std::mutex lock;
    std::unique_lock<std::mutex> locker(lock);
    static const bool init = AddResourcePathToProcedurePath();
    return init;
  }

  void SetResourcePath(const char* resource_path)
  {
    sgResourcePath = resource_path;
    std::replace(sgResourcePath.begin(),sgResourcePath.end(), '\\','/');
    if(sgResourcePath.length() > 0 && sgResourcePath[sgResourcePath.length()-1]!='/')
    {
      sgResourcePath+="/";
    }
    AddResourcePathToProcedurePath();
  }

#ifdef _WIN32
  void SetResourcePath(const wchar_t* resource_path)
  {
    SetResourcePath(resource_path ? HString(resource_path).TextA() : NULL);
  }
#endif

  template <typename T>
  struct ParamHandler
  {
  };

  template <>
  struct ParamHandler<HalconCpp::HTuple>
  {
    static void SetParameter(HDevEngineCpp::HDevProcedureCall& proc,
        const char*                                     name,
        HalconCpp::HTuple const&                        parameter)
    {
      proc.SetInputCtrlParamTuple(name, parameter);
    }

    static HalconCpp::HTuple GetParameter(
        HDevEngineCpp::HDevProcedureCall& proc, const char* name)
    {
      return proc.GetOutputCtrlParamTuple(name);
    }
  };

  template <>
  struct ParamHandler<HalconCpp::HObject>
  {
    static void SetParameter(HDevEngineCpp::HDevProcedureCall& proc,
        const char*                                     name,
        HalconCpp::HObject const&                       parameter)
    {
      proc.SetInputIconicParamObject(name, parameter);
    }

    static HalconCpp::HObject GetParameter(
        HDevEngineCpp::HDevProcedureCall& proc, const char* name)
    {
      return proc.GetOutputIconicParamObject(name);
    }
  };

  template <>
  struct ParamHandler<HalconCpp::HTupleVector>
  {
    static void SetParameter(HDevEngineCpp::HDevProcedureCall& proc,
        const char*                                     name,
        HalconCpp::HTupleVector const&                  parameter)
    {
      proc.SetInputCtrlParamVector(name, parameter);
    }

    static HalconCpp::HTupleVector GetParameter(
        HDevEngineCpp::HDevProcedureCall& proc, const char* name)
    {
      return proc.GetOutputCtrlParamVector(name);
    }
  };

  template <>
  struct ParamHandler<HalconCpp::HObjectVector>
  {
    static void SetParameter(HDevEngineCpp::HDevProcedureCall& proc,
        const char*                                     name,
        HalconCpp::HObjectVector const&                 parameter)
    {
      proc.SetInputIconicParamVector(name, parameter);
    }

    static HalconCpp::HObjectVector GetParameter(
        HDevEngineCpp::HDevProcedureCall& proc, const char* name)
    {
      return proc.GetOutputIconicParamVector(name);
    }
  };


  HDevProgram GetProgram(std::string const& program_file)
  {
    static std::mutex lock;
    static std::map<std::string,HDevProgram> programs;

    std::unique_lock<std::mutex> locker(lock);

    auto prog_iter = programs.find(program_file);
    if(prog_iter != programs.end())
    {
      return prog_iter->second;
    }
    else
    {
      HDevProgram program(program_file.c_str());
      programs[program_file] = program;
      return program;
    }
    return HDevProgram();
  }

  void get_printer_chip_region(
    HalconCpp::HObject const& Image,
    HalconCpp::HObject* ConnectedRegions,
    HalconCpp::HTuple const& MinGray)
  {     
    static HDevEngineCpp::HDevProcedure procedure(GetProgram(sgResourcePath+"segment_printer_chip.hdev"),"get_printer_chip_region");
    HDevEngineCpp::HDevProcedureCall call=procedure;
    ParamHandler<HalconCpp::HObject>::SetParameter(call,"Image",Image);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"MinGray",MinGray);
        
    call.Execute();

    if (ConnectedRegions != nullptr)
      * ConnectedRegions = ParamHandler<HalconCpp::HObject>::GetParameter(call,"ConnectedRegions");
  }

  void get_printer_chip_regions(
    HalconCpp::HObject const& Image,
    HalconCpp::HObject* ConnectedRegions,
    HalconCpp::HTuple const& MinGray)
  {     
    static HDevEngineCpp::HDevProcedure procedure(GetProgram(sgResourcePath+"segment_printer_chip.hdev"),"get_printer_chip_regions");
    HDevEngineCpp::HDevProcedureCall call=procedure;
    ParamHandler<HalconCpp::HObject>::SetParameter(call,"Image",Image);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"MinGray",MinGray);
        
    call.Execute();

    if (ConnectedRegions != nullptr)
      * ConnectedRegions = ParamHandler<HalconCpp::HObject>::GetParameter(call,"ConnectedRegions");
  }

  void threshold_printer_chip(
    HalconCpp::HObject const& Image,
    HalconCpp::HObject* Region,
    HalconCpp::HTuple const& MinGray)
  {     
    static HDevEngineCpp::HDevProcedure procedure(GetProgram(sgResourcePath+"segment_printer_chip.hdev"),"threshold_printer_chip");
    HDevEngineCpp::HDevProcedureCall call=procedure;
    ParamHandler<HalconCpp::HObject>::SetParameter(call,"Image",Image);
    ParamHandler<HalconCpp::HTuple>::SetParameter(call,"MinGray",MinGray);
        
    call.Execute();

    if (Region != nullptr)
      * Region = ParamHandler<HalconCpp::HObject>::GetParameter(call,"Region");
  }

};

