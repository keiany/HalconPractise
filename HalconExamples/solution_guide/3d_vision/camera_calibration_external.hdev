<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.1.0">
<procedure name="main">
<interface/>
<body>
<c>* Attention:</c>
<c>* This program reads the internal camera parameters from the file</c>
<c>* 'camera_parameters.dat', which, e.g., could be generated by the program</c>
<c>* 'camera_calibration_internal.hdev'</c>
<c>* </c>
<l>ImgPath := '3d_machine_vision/calib/'</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 652, 494, 'black', WindowHandle)</l>
<l>dev_update_off ()</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (1)</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<c>* Read the internal camera parameters from file</c>
<l>try</l>
<l>    read_cam_par ('camera_parameters.dat', CamParam)</l>
<l>catch (Exception)</l>
<c>    * run 'camera_calibration_internal.hdev' first to generate camera</c>
<c>    * parameter file 'camera_parameters.dat'</c>
<l>    stop ()</l>
<l>endtry</l>
<c>* </c>
<c>* Determine the external camera parameters and world coodinates from image points</c>
<c>* </c>
<c>* The external camera parameters can be determined from an image, where the</c>
<c>* calibration plate is positioned directly on the measurement plane</c>
<l>read_image (Image, ImgPath + 'calib_11')</l>
<l>dev_display (Image)</l>
<l>CaltabName := 'caltab_30mm.descr'</l>
<l>create_calib_data ('calibration_object', 1, 1, CalibDataID)</l>
<c>* Here, the final camera parameters are already known and can be used instead</c>
<c>* of the starting values used in the program 'camera_calibration_internal.hdev'</c>
<l>set_calib_data_cam_param (CalibDataID, 0, [], CamParam)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, CaltabName)</l>
<l>find_calib_object (Image, CalibDataID, 0, 0, 1, [], [])</l>
<l>get_calib_data_observ_contours (Caltab, CalibDataID, 'caltab', 0, 0, 1)</l>
<l>get_calib_data_observ_points (CalibDataID, 0, 0, 1, RCoord, CCoord, Index, PoseForCalibrationPlate)</l>
<l>dev_set_color ('green')</l>
<l>dev_display (Caltab)</l>
<l>dev_set_color ('red')</l>
<l>disp_caltab (WindowHandle, CaltabName, CamParam, PoseForCalibrationPlate, 1)</l>
<l>dev_set_line_width (3)</l>
<l>disp_circle (WindowHandle, RCoord, CCoord, gen_tuple_const(|RCoord|,1.5))</l>
<l>* caltab_points (CaltabName, X, Y, Z)</l>
<l>* calibrate_cameras (CalibDataID, Error)</l>
<c>* To take the thickness of the calibration plate into account, the z-value</c>
<c>* of the origin given by the camera pose has to be translated by the</c>
<c>* thickness of the calibration plate.</c>
<c>* Deactivate the following line if you do not want to add the correction.</c>
<l>set_origin_pose (PoseForCalibrationPlate, 0, 0, 0.00075, PoseForCalibrationPlate)</l>
<l>clear_calib_data (CalibDataID)</l>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<c>* Alternatively, the external camera parameters can  be determined from</c>
<c>* at least three point correspondances between the WCS and the pixel coordinate system</c>
<l>read_image (Image, ImgPath + 'caliper_01')</l>
<l>dev_display (Image)</l>
<c>* Set the world coordinates of three points on the rule</c>
<l>X := [0,50,100,80]</l>
<l>Y := [5,0,5,0]</l>
<l>Z := [0,0,0,0]</l>
<c>* Set the respective image plane coordinates of the three points</c>
<l>RCoord := [414,227,85,128]</l>
<l>CCoord := [119,318,550,448]</l>
<c>* </c>
<l>disp_cross (WindowHandle, RCoord, CCoord, 6, 0)</l>
<l>* create_pose (-50, 25, 400, 0, 0, -30, 'Rp+T', 'gba', 'point', InitialPose)</l>
<l>vector_to_pose (X, Y, Z, RCoord, CCoord, CamParam, 'iterative', 'error', FinalPose, Errors)</l>
<l>write_pose (FinalPose, 'pose_from_three_points.dat')</l>
<c>* Now, transform a point measured interactively into the WCS</c>
<l>dev_update_window ('on')</l>
<l>dev_display (Image)</l>
<l>while (1)</l>
<l>    disp_message (WindowHandle, 'Measure one point: left mouse button', 'window', 12, 12, 'red', 'false')</l>
<l>    disp_message (WindowHandle, 'Exit measure mode: right mouse button', 'window', 36, 12, 'red', 'false')</l>
<l>    get_mbutton (WindowHandle, Row, Column, Button)</l>
<l>    if (Button == 4)</l>
<l>        break</l>
<l>    endif</l>
<l>    dev_display (Image)</l>
<l>    dev_set_color ('green')</l>
<l>    disp_cross (WindowHandle, Row, Column, 6, 0)</l>
<l>    image_points_to_world_plane (CamParam, FinalPose, Row, Column, 1, X1, Y1)</l>
<l>    disp_message (WindowHandle, 'X = ' + X1, 'window', 320, 400, 'red', 'false')</l>
<l>    disp_message (WindowHandle, 'Y = ' + Y1, 'window', 340, 400, 'red', 'false')</l>
<l>endwhile</l>
<c>* Apply the measure tool and transform the resulting point coordinates</c>
<c>* into the WCS</c>
<l>dev_set_color ('red')</l>
<l>dev_display (Image)</l>
<c>* Set the world coordinates of four points defining a ROI for the measure tool</c>
<l>ROI_X_WCS := [-2,-2,112,112]</l>
<l>ROI_Y_WCS := [0,0.5,0.5,0]</l>
<l>ROI_Z_WCS := [0,0,0,0]</l>
<c>* Determine the transformation matrix from the WCS into the CCS</c>
<l>pose_to_hom_mat3d (FinalPose, CCS_HomMat_WCS)</l>
<c>* Transform the point coordintes into the image coordinate system</c>
<l>affine_trans_point_3d (CCS_HomMat_WCS, ROI_X_WCS, ROI_Y_WCS, ROI_Z_WCS, CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ)</l>
<l>project_3d_point (CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ, CamParam, RectangleRow, RectangleCol)</l>
<l>gen_region_polygon_filled (ROI, RectangleRow, RectangleCol)</l>
<l>smallest_rectangle2 (ROI, RowCenterROI, ColCenterROI, PhiROI, Length1ROI, Length2ROI)</l>
<c>* Create a measure</c>
<l>gen_measure_rectangle2 (RowCenterROI, ColCenterROI, PhiROI, Length1ROI, Length2ROI, 652, 494, 'bilinear', MeasureHandle)</l>
<l>measure_pairs (Image, MeasureHandle, 0.4, 5, 'all_strongest', 'all', RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, IntraDistance, InterDistance)</l>
<l>close_measure (MeasureHandle)</l>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle, 'Measuring the position of the pitch lines', 'window', 450, 25, 'red', 'false')</l>
<l>dev_set_color ('green')</l>
<l>RowPitchLine := (RowEdgeFirst + RowEdgeSecond) / 2.0</l>
<l>ColPitchLine := (ColumnEdgeFirst + ColumnEdgeSecond) / 2.0</l>
<l>disp_cross (WindowHandle, RowPitchLine, ColPitchLine, 6, 0)</l>
<l>image_points_to_world_plane (CamParam, FinalPose, RowPitchLine, ColPitchLine, 1, X1, Y1)</l>
<l>for I := 1 to |X1| by 1</l>
<l>    set_tposition (WindowHandle, RowEdgeFirst[I - 1] + 5, ColumnEdgeFirst[I - 1] - 20)</l>
<l>    if (I == |X1|)</l>
<l>        set_tposition (WindowHandle, RowEdgeFirst[I - 1], ColumnEdgeFirst[I - 2])</l>
<l>    endif</l>
<l>    write_string (WindowHandle, X1[I - 1]$'.3f' + 'mm')</l>
<l>endfor</l>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<l>dev_display (Image)</l>
<c>* Apply a line extraction and transform the resulting XLD contours</c>
<c>* into the WCS</c>
<c>* Set the world coordinates of four points defining a ROI</c>
<l>ROI_X_WCS := [11,11,13,13]</l>
<l>ROI_Y_WCS := [4,6,6,4]</l>
<l>ROI_Z_WCS := [0,0,0,0]</l>
<c>* Transform the point coordinates into the image coordinate system</c>
<l>affine_trans_point_3d (CCS_HomMat_WCS, ROI_X_WCS, ROI_Y_WCS, ROI_Z_WCS, CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ)</l>
<l>project_3d_point (CCS_RectangleX, CCS_RectangleY, CCS_RectangleZ, CamParam, RectangleRow, RectangleCol)</l>
<c>* Visualize the square in the original image</c>
<l>disp_polygon (WindowHandle, [RectangleRow,RectangleRow[0]], [RectangleCol,RectangleCol[0]])</l>
<l>dev_display (Image)</l>
<c>* create the ROI</c>
<l>gen_region_polygon_filled (ROI, RectangleRow, RectangleCol)</l>
<l>reduce_domain (Image, ROI, ImageReduced)</l>
<c>* Extract the lines</c>
<l>lines_gauss (ImageReduced, Lines, 1, 3, 8, 'dark', 'true', 'bar-shaped', 'true')</l>
<c>* Adapt the pose of the measurement plane to the tilted plane of the vernier</c>
<l>RelPose := [0,3.2,0,-14,0,0,0]</l>
<l>pose_to_hom_mat3d (FinalPose, HomMat3D)</l>
<l>pose_to_hom_mat3d (RelPose, HomMat3DRel)</l>
<l>hom_mat3d_compose (HomMat3D, HomMat3DRel, HomMat3DAdapted)</l>
<c>* Alternatively, the adaption can be done using the operators</c>
<c>* hom_mat3d_translate_local and hom_mat3d_rotate_local</c>
<c>* as shown in the following two lines</c>
<l>hom_mat3d_translate_local (HomMat3D, 0, 3.2, 0, HomMat3DTranslate)</l>
<l>hom_mat3d_rotate_local (HomMat3DTranslate, rad(-14), 'x', HomMat3DAdapted)</l>
<l>hom_mat3d_to_pose (HomMat3DAdapted, PoseAdapted)</l>
<c>* Transform the XLD contour to the WCS using the adapted pose</c>
<l>contour_to_world_plane_xld (Lines, ContoursTrans, CamParam, PoseAdapted, 1)</l>
<l>get_contour_xld (ContoursTrans, YOfContour, XOfContour)</l>
<l>tuple_mean (XOfContour, MeterReading)</l>
<l>dev_display (Lines)</l>
<l>disp_message (WindowHandle, 'Meter reading: ' + MeterReading$'.3f' + 'mm', 'window', 400, 180, 'green', 'false')</l>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<l>dev_close_inspect_ctrl (YOfContour)</l>
<l>dev_close_inspect_ctrl (XOfContour)</l>
<c>* Now, transform the whole image</c>
<l>WidthMappedImage := 652</l>
<l>HeightMappedImage := 494</l>
<l>dev_display (Image)</l>
<c>* First, determine the scale for the mapping</c>
<c>* (here, the scale is determined such that in the</c>
<c>* surroundings of the points P0 and P1, the image scale of the</c>
<c>* mapped image is similar to the image scale of the original image)</c>
<l>distance_pp (X[0], Y[0], X[1], Y[1], DistP0P1WCS)</l>
<l>distance_pp (RCoord[0], CCoord[0], RCoord[1], CCoord[1], DistP0P1PCS)</l>
<l>Scale := DistP0P1WCS / DistP0P1PCS</l>
<c>* Then, determine the parameter settings for set_origin_pose such</c>
<c>* that the point given via get_mbutton will be in the center of the</c>
<c>* mapped image</c>
<l>dev_display (Image)</l>
<l>disp_message (WindowHandle, 'Define the center of the mapped image', 'window', 12, 12, 'red', 'false')</l>
<l>get_mbutton (WindowHandle, CenterRow, CenterColumn, Button1)</l>
<l>image_points_to_world_plane (CamParam, FinalPose, CenterRow, CenterColumn, 1, CenterX, CenterY)</l>
<l>set_origin_pose (FinalPose, CenterX - Scale * WidthMappedImage / 2.0, CenterY - Scale * HeightMappedImage / 2.0, 0, PoseNewOrigin)</l>
<l>gen_image_to_world_plane_map (Map, CamParam, PoseNewOrigin, 652, 494, WidthMappedImage, HeightMappedImage, Scale, 'bilinear')</l>
<l>map_image (Image, Map, ImageMapped)</l>
<l>dev_clear_window ()</l>
<l>dev_display (ImageMapped)</l>
<c>* In the case that only one image has to be mapped, the operator</c>
<c>* image_to_world_plane can be used instead of the operators</c>
<c>* gen_image_to_world_plane_map and map_image.</c>
<l>image_to_world_plane (Image, ImageMapped, CamParam, PoseNewOrigin, WidthMappedImage, HeightMappedImage, Scale, 'bilinear')</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
