<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.1.0">
<procedure name="main">
<interface/>
<body>
<l>dev_update_off ()</l>
<c>* Set the image path</c>
<l>ImgPath := '3d_machine_vision/stereo/'</l>
<c>* Read the first images to get their size</c>
<l>I := 0</l>
<l>read_image (ImageL, ImgPath + 'calib_distorted_l_' + I$'03d')</l>
<l>read_image (ImageR, ImgPath + 'calib_distorted_r_' + I$'03d')</l>
<c>* Reopen the windows with an appropriate size</c>
<l>dev_close_window ()</l>
<l>get_image_size (ImageL, WidthL, HeightL)</l>
<l>get_image_size (ImageR, WidthR, HeightR)</l>
<l>dev_open_window (0, 0, WidthL, HeightL, 'black', WindowHandle1)</l>
<l>set_display_font (WindowHandle1, 14, 'mono', 'true', 'false')</l>
<l>dev_open_window (0, WidthL + 12, WidthL, HeightL, 'black', WindowHandle2)</l>
<c>* Set the initial values for the internal camera parameters</c>
<l>gen_cam_par_area_scan_division (0.0125, 0, 7.4e-6, 7.4e-6, WidthL / 2.0, HeightL / 2.0, WidthL, HeightL, StartCamParL)</l>
<l>StartCamParR := StartCamParL</l>
<c>* Create a calibration data model in which all calibration data</c>
<c>* including the image coordinates of the calibration marks and</c>
<c>* the observation poses of the calibration plate will be</c>
<c>* accumulated</c>
<l>create_calib_data ('calibration_object', 2, 1, CalibDataID)</l>
<l>set_calib_data_cam_param (CalibDataID, 0, [], StartCamParL)</l>
<l>set_calib_data_cam_param (CalibDataID, 1, [], StartCamParR)</l>
<l>set_calib_data_calib_object (CalibDataID, 0, 'caltab_30mm.descr')</l>
<c>* Start the loop over the calibration images</c>
<l>for I := 0 to 10 by 1</l>
<c>    * Read and display the calibration images</c>
<l>    read_image (ImageL, ImgPath + 'calib_distorted_l_' + I$'03d')</l>
<l>    read_image (ImageR, ImgPath + 'calib_distorted_r_' + I$'03d')</l>
<l>    dev_set_window (WindowHandle1)</l>
<l>    dev_display (ImageL)</l>
<l>    dev_set_window (WindowHandle2)</l>
<l>    dev_display (ImageR)</l>
<c>    * Find the calibration plate and store observations</c>
<c>    * in the calibration data model</c>
<l>    find_calib_object (ImageL, CalibDataID, 0, 0, I, [], [])</l>
<l>    find_calib_object (ImageR, CalibDataID, 1, 0, I, [], [])</l>
<c>    * Visualize the extracted calibration marks and the</c>
<c>    * coordinate system defined by the estimated pose.</c>
<l>    visualize_observation_results (ImageL, CalibDataID, 0, I, WindowHandle1)</l>
<l>    visualize_observation_results (ImageR, CalibDataID, 1, I, WindowHandle2)</l>
<l>    wait_seconds (.2)</l>
<l>endfor</l>
<c>* Perform the actual calibration</c>
<l>calibrate_cameras (CalibDataID, Errors)</l>
<c>* Get the calibrated camera parameters</c>
<l>get_calib_data (CalibDataID, 'camera', 0, 'params', CamParamL)</l>
<l>get_calib_data (CalibDataID, 'camera', 1, 'params', CamParamR)</l>
<c>* Since the left camera is the reference camera for the</c>
<c>* calib data model, the pose of the right camera is its</c>
<c>* pose relative to the left camera</c>
<l>get_calib_data (CalibDataID, 'camera', 1, 'pose', cLPcR)</l>
<c>* Store the results into files. Here, you can either store the</c>
<c>* individual results</c>
<l>write_cam_par (CamParamL, 'cam_left-125.dat')</l>
<l>write_cam_par (CamParamR, 'cam_right-125.dat')</l>
<l>write_pose (cLPcR, 'pos_right2left.dat')</l>
<c>* or you store the complete camera setup model and thus enable</c>
<c>* the later access to all contained parameters</c>
<l>get_calib_data (CalibDataID, 'model', 'general', 'camera_setup_model', CameraSetupModelID)</l>
<l>write_camera_setup_model (CameraSetupModelID, 'stereo_camera_setup.csm')</l>
<c>* Generate the rectification maps</c>
<l>gen_binocular_rectification_map (MapL, MapR, CamParamL, CamParamR, cLPcR, 1, 'viewing_direction', 'bilinear', RectCamParL, RectCamParR, CamPoseRectL, CamPoseRectR, RectLPosRectR)</l>
<c>* Read in a stereo image pair, aquired with the stereo camera system,</c>
<c>* which has been calibrated, just now.</c>
<l>read_image (ImageL, ImgPath + 'caliper_distorted_l')</l>
<l>read_image (ImageR, ImgPath + 'caliper_distorted_r')</l>
<c>* Rectify the stereo images and display them</c>
<l>map_image (ImageL, MapL, ImageRectifiedL)</l>
<l>map_image (ImageR, MapR, ImageRectifiedR)</l>
<l>dev_set_window (WindowHandle1)</l>
<l>dev_clear_window ()</l>
<l>dev_display (ImageRectifiedL)</l>
<l>disp_message (WindowHandle1, 'Rectified images', 'window', 12, 12, 'black', 'true')</l>
<l>dev_set_window (WindowHandle2)</l>
<l>dev_clear_window ()</l>
<l>dev_display (ImageRectifiedR)</l>
<l>clear_calib_data (CalibDataID)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="visualize_observation_results">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="CalibDataID" base_type="ctrl" dimension="0"/>
<par name="CameraIdx" base_type="ctrl" dimension="0"/>
<par name="PoseIdx" base_type="ctrl" dimension="0"/>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>get_calib_data_observ_points (CalibDataID, CameraIdx, 0, PoseIdx, RCoord, CCoord, Index, Pose)</l>
<l>get_calib_data (CalibDataID, 'camera', CameraIdx, 'init_params', CamPar)</l>
<c>* </c>
<l>dev_set_window (WindowHandle)</l>
<l>dev_display (Image)</l>
<l>dev_set_color ('yellow')</l>
<l>gen_cross_contour_xld (Cross, RCoord, CCoord, 6, 0.785398)</l>
<l>dev_display (Cross)</l>
<l>ArrowLength := 0.02</l>
<l>ArrowX_CPCS := [0,ArrowLength,0]</l>
<l>ArrowY_CPCS := [0,0,ArrowLength]</l>
<l>ArrowZ_CPCS := [0,0,0]</l>
<l>pose_to_hom_mat3d (Pose, HomMat_CPCS_CCS)</l>
<l>affine_trans_point_3d (HomMat_CPCS_CCS, ArrowX_CPCS, ArrowY_CPCS, ArrowZ_CPCS, ArrowX_CCS, ArrowY_CCS, ArrowZ_CCS)</l>
<l>project_3d_point (ArrowX_CCS, ArrowY_CCS, ArrowZ_CCS, CamPar, ArrowRow, ArrowColumn)</l>
<l>dev_set_color ('green')</l>
<l>gen_arrow_contour_xld (ArrowX, ArrowRow[0], ArrowColumn[0], ArrowRow[1], ArrowColumn[1], 5, 5)</l>
<l>gen_arrow_contour_xld (ArrowY, ArrowRow[0], ArrowColumn[0], ArrowRow[2], ArrowColumn[2], 5, 5)</l>
<l>dev_display (ArrowX)</l>
<l>dev_display (ArrowY)</l>
<l>set_tposition (WindowHandle, ArrowRow[1], ArrowColumn[1])</l>
<l>write_string (WindowHandle, 'x')</l>
<l>set_tposition (WindowHandle, ArrowRow[2], ArrowColumn[2])</l>
<l>write_string (WindowHandle, 'y')</l>
<l>dev_set_color ('white')</l>
<l>return ()</l>
</body>
<docu id="visualize_observation_results">
<parameters>
<parameter id="CalibDataID"/>
<parameter id="CameraIdx"/>
<parameter id="Image"/>
<parameter id="PoseIdx"/>
<parameter id="WindowHandle"/>
</parameters>
</docu>
</procedure>
</hdevelop>
