<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.0.0">
<procedure name="main">
<interface/>
<body>
<c>* </c>
<c>* Example for the usage of the TurboDrive feature</c>
<c>* (GigE Vision cameras)</c>
<c>* </c>
<l>info_framegrabber ('SaperaLT', 'device', Information, DeviceList)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2,1]" as_ord="1">open_framegrabber ('SaperaLT', 1, 1, 0, 0, 0, 0, 'default', 8, 'default', -1, 'false', '', DeviceList[0], -1, -1, AcqHandle)</l>
<c>* Set maximal width and height.</c>
<l>get_framegrabber_param (AcqHandle, 'Width_range', WidthRange)</l>
<l>get_framegrabber_param (AcqHandle, 'Height_range', HeightRange)</l>
<l>set_framegrabber_param (AcqHandle, 'Width', WidthRange[1])</l>
<l>set_framegrabber_param (AcqHandle, 'Height', HeightRange[1])</l>
<l>get_framegrabber_param (AcqHandle, 'Width', Width)</l>
<l>get_framegrabber_param (AcqHandle, 'Height', Height)</l>
<c>* Set maximal pixel format.</c>
<l>get_framegrabber_param (AcqHandle, 'PixelFormat_values', PixelFormatValues)</l>
<l>set_framegrabber_param (AcqHandle, 'PixelFormat', PixelFormatValues[1])</l>
<l>get_framegrabber_param (AcqHandle, 'PixelFormat', PixelFormat)</l>
<c>* Set maximal frame rate.</c>
<l>get_framegrabber_param (AcqHandle, 'AcquisitionFrameRate_range', FrameRateRange)</l>
<l>set_framegrabber_param (AcqHandle, 'AcquisitionFrameRate', FrameRateRange[1])</l>
<l>get_framegrabber_param (AcqHandle, 'AcquisitionFrameRate', FrameRate)</l>
<c>* Enable TURBO TRANSFER MODE.</c>
<l>try</l>
<l>    set_framegrabber_param (AcqHandle, 'turboTransferEnable', 'enable')</l>
<l>catch (Exception)</l>
<l>    turbo_not_supported (AcqHandle)</l>
<l>    return ()</l>
<l>endtry</l>
<c>* Set continuous grabbing.</c>
<l>set_framegrabber_param (AcqHandle, 'continuous_grabbing', 'enable')</l>
<c>* </c>
<c>* Check if the full frame rate is achieved and if no images have</c>
<c>* been lost.</c>
<l>dev_update_off ()</l>
<l>NumImages := 0</l>
<l>FrameRateSum := 0</l>
<l>ValidFrameRate := true</l>
<l>grab_image_start (AcqHandle, -1)</l>
<l>count_seconds (SecondsBegin)</l>
<l>grab_image_async (Image, AcqHandle, -1)</l>
<l>get_framegrabber_param (AcqHandle, 'buffer_time_stamp', BufferTimeStamp)</l>
<l>repeat</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,3]" as_ord="1">    grab_image_async (Image, AcqHandle, -1)</l>
<c>    * Get Transfer Queue Current Block Count, which returns the</c>
<c>    * number of frames buffered within the device pending to be</c>
<c>    * transfer to the host system. If the value increases then</c>
<c>    * there is a problem with the network or host bandwidth</c>
<c>    * being exceeded. The ImageLost event occurs when all buffer</c>
<c>    * space is consumed.</c>
<l>    get_framegrabber_param (AcqHandle, 'transferQueueCurrentBlockCount', TransferQueueCurrentBlockCount)</l>
<l>    TransferQueueCurrentBlockCountValues[NumImages] := TransferQueueCurrentBlockCount</l>
<c>    * Get buffer_time_stamp [microseconds].</c>
<l>    BufferTimeStampPrev := BufferTimeStamp</l>
<l>    get_framegrabber_param (AcqHandle, 'buffer_time_stamp', BufferTimeStamp)</l>
<l>    if (BufferTimeStamp == 0)</l>
<c>        * The buffer time stamp should not be zero, but if it</c>
<c>        * happens, the frame rate can not be calculated.</c>
<l>        ValidFrameRate := false</l>
<l>    else</l>
<l>        BufferTimeStampValues[NumImages] := BufferTimeStamp - BufferTimeStampPrev</l>
<l>        FrameRateSum := FrameRateSum + (1e6 / BufferTimeStampValues[NumImages])</l>
<l>    endif</l>
<l>    NumImages := NumImages + 1</l>
<l>    count_seconds (SecondsCurrent)</l>
<l>until ((SecondsCurrent - SecondsBegin) &gt; 20)</l>
<l>dev_update_on ()</l>
<l>show_results (ValidFrameRate, FrameRate, FrameRateSum, BufferTimeStampValues, TransferQueueCurrentBlockCountValues, FrameRateMeas)</l>
<c>* </c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[4,1]" as_ord="1">close_framegrabber (AcqHandle)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="show_results">
<interface>
<ic>
<par name="ValidFrameRate" base_type="ctrl" dimension="0"/>
<par name="FrameRate" base_type="ctrl" dimension="0"/>
<par name="FrameRateSum" base_type="ctrl" dimension="0"/>
<par name="BufferTimeStampValues" base_type="ctrl" dimension="0"/>
<par name="TransferQueueCurrentBlockCountValues" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FrameRateMeas" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 600, 150, 'white', WindowHandle)</l>
<l>set_display_font (WindowHandle, 20, 'mono', 'true', 'false')</l>
<c>* </c>
<l>if (ValidFrameRate)</l>
<c>    * Calculate frame rate</c>
<l>    FrameRateMeas := FrameRateSum / |BufferTimeStampValues|</l>
<c>    * Check the measured frame rate and the time between frames to</c>
<c>    * see if images have been lost.</c>
<l>    Min := min(BufferTimeStampValues)</l>
<l>    Max := max(BufferTimeStampValues)</l>
<l>    if ((Min != Max) or (FrameRateMeas &lt; (FrameRate * 0.98)))</l>
<l>        dev_disp_text ('Camera frame rate: ' + FrameRate + ' fps\nMeasured frame rate: ' + FrameRateMeas + ' fps', 'window', 28, 50, 'red', [], [])</l>
<l>        dev_disp_text ('Dropped frames found!', 'window', 80, 50, 'blue', [], [])</l>
<l>        dev_inspect_ctrl (['plot',BufferTimeStampValues])</l>
<l>        dev_inspect_ctrl (['plot',TransferQueueCurrentBlockCountValues])</l>
<l>    else</l>
<l>        dev_disp_text ('Camera frame rate: ' + FrameRate + ' fps\nMeasured frame rate: ' + FrameRateMeas + ' fps', 'window', 28, 50, 'green', [], [])</l>
<l>    endif</l>
<l>    set_display_font (WindowHandle, 12, 'mono', 'true', 'false')</l>
<l>    dev_disp_text ('Press Run (F5) to continue', 'window', 'bottom', 'right', 'black', [], [])</l>
<l>    stop ()</l>
<l>    dev_close_window ()</l>
<l>    dev_close_inspect_ctrl (['plot',TransferQueueCurrentBlockCountValues])</l>
<l>    dev_close_inspect_ctrl (['plot',BufferTimeStampValues])</l>
<l>else</l>
<c>    * If not possible to calculate the frame rate, just take a look at</c>
<c>    * the Transfer Queue Current Block Count.</c>
<l>    dev_inspect_ctrl (['plot',TransferQueueCurrentBlockCountValues])</l>
<l>    stop ()</l>
<l>    dev_close_inspect_ctrl (['plot',TransferQueueCurrentBlockCountValues])</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="show_results">
<parameters>
<parameter id="BufferTimeStampValues"/>
<parameter id="FrameRate"/>
<parameter id="FrameRateMeas"/>
<parameter id="FrameRateSum"/>
<parameter id="TransferQueueCurrentBlockCountValues"/>
<parameter id="ValidFrameRate"/>
</parameters>
</docu>
</procedure>
<procedure name="turbo_not_supported">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 600, 100, 'white', WindowHandle)</l>
<l>set_display_font (WindowHandle, 22, 'mono', 'true', 'false')</l>
<l>disp_message (WindowHandle, 'Turbo transfer mode not supported!', 'window', 32, 50, 'red', 'false')</l>
<l>set_display_font (WindowHandle, 12, 'mono', 'true', 'false')</l>
<l>disp_continue_message (WindowHandle, 'black', 'false')</l>
<l>stop ()</l>
<l>dev_close_window ()</l>
<l>close_framegrabber (AcqHandle)</l>
<l>return ()</l>
</body>
<docu id="turbo_not_supported">
<parameters>
<parameter id="AcqHandle"/>
</parameters>
</docu>
</procedure>
</hdevelop>
